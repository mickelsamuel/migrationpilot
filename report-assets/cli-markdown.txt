# Migration Safety Report

**File**: `C:\Users\micke\Desktop\Money\migrationpilot\demo-unsafe.sql`  
**Risk Level**: YELLOW (score: 40/100)  
**Statements**: 5 | **Critical**: 9 | **Warnings**: 4

---

## DDL Operations

| # | Statement | Lock Type | Blocks | Long Held | Risk |
|---|-----------|-----------|--------|-----------|------|
| 1 | `-- Unsafe migration example CREATE INDEX idx_users_email ...` | SHARE | Writes | Yes | YELLOW |
| 2 | `ALTER TABLE orders ADD COLUMN total numeric DEFAULT 0` | ACCESS EXCLUSIVE | R+W | No | YELLOW |
| 3 | `ALTER TABLE users ALTER COLUMN name TYPE varchar(50)` | ACCESS EXCLUSIVE | R+W | Yes | YELLOW |
| 4 | `VACUUM FULL users` | ACCESS EXCLUSIVE | R+W | Yes | YELLOW |
| 5 | `DROP TABLE legacy_data` | ACCESS EXCLUSIVE | R+W | No | YELLOW |

## Violations

### ðŸ”´ CRITICAL: MP001 (line 1)

CREATE INDEX "idx_users_email" without CONCURRENTLY will lock all writes on "users" for the entire duration of index creation.

> **Why:** Without CONCURRENTLY, PostgreSQL takes an ACCESS EXCLUSIVE lock on the table, blocking all reads and writes for the entire duration of index creation. On tables with millions of rows, this can mean minutes of complete downtime.

[Documentation](https://migrationpilot.dev/rules/mp001)

**Safe alternative:**

```sql
-- Unsafe migration example
CREATE INDEX CONCURRENTLY idx_users_email ON users (email)
```

### ðŸ”´ CRITICAL: MP004 (line 1)

DDL statement acquires SHARE lock without a preceding SET lock_timeout. Without a timeout, this statement could block the lock queue indefinitely if it can't acquire the lock, causing cascading query failures.

> **Why:** Without lock_timeout, if the table is locked by another query, your DDL waits indefinitely. All subsequent queries pile up behind it in the lock queue, causing cascading timeouts across your application. GoCardless enforces a 750ms lock_timeout for this reason.

[Documentation](https://migrationpilot.dev/rules/mp004)

**Safe alternative:**

```sql
-- Set a timeout so DDL fails fast instead of blocking the queue
SET lock_timeout = '5s';
-- Unsafe migration example
CREATE INDEX idx_users_email ON users (email)
RESET lock_timeout;
```

### ðŸŸ¡ WARNING: MP020 (line 1)

Long-running DDL without a preceding SET statement_timeout. This operation could hold locks for an extended time if it runs longer than expected.

> **Why:** Without statement_timeout, a DDL operation that encounters unexpected conditions (bloated table, heavy WAL, slow I/O) can hold locks for hours, turning a routine migration into a full outage.

[Documentation](https://migrationpilot.dev/rules/mp020)

**Safe alternative:**

```sql
-- Set a timeout so the operation is killed if it runs too long
SET statement_timeout = '30s';
-- Unsafe migration example
CREATE INDEX idx_users_email ON users (email)
RESET statement_timeout;
```

### ðŸŸ¡ WARNING: MP023 (line 1)

CREATE INDEX "idx_users_email" without IF NOT EXISTS will fail if the index already exists. Use IF NOT EXISTS for idempotent migrations.

> **Why:** Without IF NOT EXISTS, re-running a migration fails with "relation already exists". Idempotent migrations are safer for retry and rollback scenarios, and required by many deployment pipelines.

[Documentation](https://migrationpilot.dev/rules/mp023)

**Safe alternative:**

```sql
-- Unsafe migration example
CREATE INDEX IF NOT EXISTS idx_users_email ON users (email)
```

### ðŸ”´ CRITICAL: MP004 (line 2)

DDL statement acquires ACCESS EXCLUSIVE lock without a preceding SET lock_timeout. Without a timeout, this statement could block the lock queue indefinitely if it can't acquire the lock, causing cascading query failures.

> **Why:** Without lock_timeout, if the table is locked by another query, your DDL waits indefinitely. All subsequent queries pile up behind it in the lock queue, causing cascading timeouts across your application. GoCardless enforces a 750ms lock_timeout for this reason.

[Documentation](https://migrationpilot.dev/rules/mp004)

**Safe alternative:**

```sql
-- Set a timeout so DDL fails fast instead of blocking the queue
SET lock_timeout = '5s';
ALTER TABLE orders ADD COLUMN total numeric DEFAULT 0
RESET lock_timeout;
```

### ðŸ”´ CRITICAL: MP004 (line 3)

DDL statement acquires ACCESS EXCLUSIVE lock without a preceding SET lock_timeout. Without a timeout, this statement could block the lock queue indefinitely if it can't acquire the lock, causing cascading query failures.

> **Why:** Without lock_timeout, if the table is locked by another query, your DDL waits indefinitely. All subsequent queries pile up behind it in the lock queue, causing cascading timeouts across your application. GoCardless enforces a 750ms lock_timeout for this reason.

[Documentation](https://migrationpilot.dev/rules/mp004)

**Safe alternative:**

```sql
-- Set a timeout so DDL fails fast instead of blocking the queue
SET lock_timeout = '5s';
ALTER TABLE users ALTER COLUMN name TYPE varchar(50)
RESET lock_timeout;
```

### ðŸ”´ CRITICAL: MP007 (line 3)

ALTER COLUMN TYPE on "users"."name" rewrites the entire table under ACCESS EXCLUSIVE lock, blocking all reads and writes.

> **Why:** Changing a column type rewrites every row in the table while holding an ACCESS EXCLUSIVE lock that blocks all reads and writes. On large tables this can take hours, causing extended downtime.

[Documentation](https://migrationpilot.dev/rules/mp007)

**Safe alternative:**

```sql
-- Use the expand-contract pattern:
-- Step 1: Add new column with desired type
ALTER TABLE users ADD COLUMN name_new <new_type>;

-- Step 2: Backfill in batches
UPDATE users SET name_new = name::<new_type>
  WHERE id IN (SELECT id FROM users WHERE name_new IS NULL LIMIT 10000);

-- Step 3: Create trigger to sync writes (during backfill)
-- Step 4: Swap columns (brief lock)
-- Step 5: Drop old column
```

### ðŸŸ¡ WARNING: MP020 (line 3)

Long-running DDL without a preceding SET statement_timeout. This operation could hold locks for an extended time if it runs longer than expected.

> **Why:** Without statement_timeout, a DDL operation that encounters unexpected conditions (bloated table, heavy WAL, slow I/O) can hold locks for hours, turning a routine migration into a full outage.

[Documentation](https://migrationpilot.dev/rules/mp020)

**Safe alternative:**

```sql
-- Set a timeout so the operation is killed if it runs too long
SET statement_timeout = '30s';
ALTER TABLE users ALTER COLUMN name TYPE varchar(50)
RESET statement_timeout;
```

### ðŸ”´ CRITICAL: MP004 (line 4)

DDL statement acquires ACCESS EXCLUSIVE lock without a preceding SET lock_timeout. Without a timeout, this statement could block the lock queue indefinitely if it can't acquire the lock, causing cascading query failures.

> **Why:** Without lock_timeout, if the table is locked by another query, your DDL waits indefinitely. All subsequent queries pile up behind it in the lock queue, causing cascading timeouts across your application. GoCardless enforces a 750ms lock_timeout for this reason.

[Documentation](https://migrationpilot.dev/rules/mp004)

**Safe alternative:**

```sql
-- Set a timeout so DDL fails fast instead of blocking the queue
SET lock_timeout = '5s';
VACUUM FULL users
RESET lock_timeout;
```

### ðŸ”´ CRITICAL: MP006 (line 4)

VACUUM FULL on "users" rewrites the entire table under ACCESS EXCLUSIVE lock. This blocks ALL reads and writes for the entire duration.

> **Why:** VACUUM FULL rewrites the entire table to a new file, holding an ACCESS EXCLUSIVE lock for the full duration. On large tables this can take hours. Use regular VACUUM or pg_repack for online table compaction instead.

[Documentation](https://migrationpilot.dev/rules/mp006)

**Safe alternative:**

```sql
-- Use pg_repack instead (no ACCESS EXCLUSIVE lock during rewrite):
-- Install: CREATE EXTENSION pg_repack;
-- Run: pg_repack --table users --no-superuser-check
```

### ðŸŸ¡ WARNING: MP020 (line 4)

Long-running DDL without a preceding SET statement_timeout. This operation could hold locks for an extended time if it runs longer than expected.

> **Why:** Without statement_timeout, a DDL operation that encounters unexpected conditions (bloated table, heavy WAL, slow I/O) can hold locks for hours, turning a routine migration into a full outage.

[Documentation](https://migrationpilot.dev/rules/mp020)

**Safe alternative:**

```sql
-- Set a timeout so the operation is killed if it runs too long
SET statement_timeout = '30s';
VACUUM FULL users
RESET statement_timeout;
```

### ðŸ”´ CRITICAL: MP004 (line 5)

DDL statement acquires ACCESS EXCLUSIVE lock without a preceding SET lock_timeout. Without a timeout, this statement could block the lock queue indefinitely if it can't acquire the lock, causing cascading query failures.

> **Why:** Without lock_timeout, if the table is locked by another query, your DDL waits indefinitely. All subsequent queries pile up behind it in the lock queue, causing cascading timeouts across your application. GoCardless enforces a 750ms lock_timeout for this reason.

[Documentation](https://migrationpilot.dev/rules/mp004)

**Safe alternative:**

```sql
-- Set a timeout so DDL fails fast instead of blocking the queue
SET lock_timeout = '5s';
DROP TABLE legacy_data
RESET lock_timeout;
```

### ðŸ”´ CRITICAL: MP026 (line 5)

DROP TABLE "legacy_data" permanently removes the table and all its data. This is irreversible and takes an ACCESS EXCLUSIVE lock.

> **Why:** DROP TABLE is irreversible â€” it permanently deletes the table, all rows, indexes, constraints, triggers, and policies. In production, this means instant data loss. Prefer renaming the table first, keeping it as a backup, then dropping later after confirming no dependencies.

[Documentation](https://migrationpilot.dev/rules/mp026)

**Safe alternative:**

```sql
-- Step 1: Rename the table (keeps data as backup)
ALTER TABLE legacy_data RENAME TO legacy_data_deprecated;

-- Step 2: After confirming no application depends on it, drop later
-- DROP TABLE legacy_data_deprecated;
```

## Risk Factors

| Factor | Score | Detail |
|--------|------:|--------|
| Lock Severity | 40/40 | ACCESS EXCLUSIVE (long-held) |

---

*Generated by [MigrationPilot](https://migrationpilot.dev)*
Assertion failed: !(handle->flags & UV_HANDLE_CLOSING), file src\win\async.c, line 76
