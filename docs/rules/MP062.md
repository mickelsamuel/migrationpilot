# MP062: ban-add-generated-stored-column

**Severity**: Critical | **Auto-fixable**: No | **Tier**: Free

## What It Detects
ALTER TABLE ... ADD COLUMN with GENERATED ALWAYS AS (...) STORED, which causes a full table rewrite under ACCESS EXCLUSIVE lock.

## Why It's Dangerous
Adding a stored generated column rewrites every existing row to compute and store the expression. On tables with millions of rows, this holds an ACCESS EXCLUSIVE lock for the entire rewrite duration â€” blocking all reads and writes. The operation is equivalent to adding a column with a non-null default on pre-PG11, but there is no concurrent alternative.

## Bad Example
```sql
ALTER TABLE users
  ADD COLUMN full_name TEXT
  GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED;
-- Full table rewrite under ACCESS EXCLUSIVE lock
-- Blocks all queries for the entire duration
```

## Good Example
```sql
-- Use a regular column + trigger instead
ALTER TABLE users ADD COLUMN full_name TEXT;

CREATE FUNCTION update_full_name() RETURNS trigger AS $$
BEGIN
  NEW.full_name := NEW.first_name || ' ' || NEW.last_name;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_full_name
  BEFORE INSERT OR UPDATE ON users
  FOR EACH ROW EXECUTE FUNCTION update_full_name();

-- Backfill in batches
UPDATE users SET full_name = first_name || ' ' || last_name
  WHERE id BETWEEN 1 AND 10000;
```

## Auto-fix
This rule is not auto-fixable. Use a regular column with a trigger or application-level computation instead.

## Configuration
```yaml
rules:
  MP062: false           # disable
  MP062:
    severity: warning    # downgrade from critical to warning
```

## Links
- [PostgreSQL Generated Columns](https://www.postgresql.org/docs/current/ddl-generated-columns.html)
- [Table Rewrites and Lock Impact](https://www.postgresql.org/docs/current/sql-altertable.html)
