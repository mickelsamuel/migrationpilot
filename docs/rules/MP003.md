# MP003: volatile-default-table-rewrite

**Severity**: Critical | **Auto-fixable**: No | **Tier**: Free

## What It Detects
ADD COLUMN with a volatile DEFAULT (e.g., now(), random()) causes a full table rewrite on PG < 11, and still evaluates per-row on PG 11+.

## Why It's Dangerous
On PostgreSQL 10 and earlier, a volatile default triggers a full table rewrite under ACCESS EXCLUSIVE lock. Even on PG 11+, volatile defaults evaluate per-row at read time, which can cause unexpected behavior for existing rows.

## Bad Example
```sql
ALTER TABLE orders ADD COLUMN created_at timestamptz DEFAULT now();
```

## Good Example
```sql
-- Add column without default, then backfill:
ALTER TABLE orders ADD COLUMN created_at timestamptz;

-- Backfill in batches:
UPDATE orders SET created_at = now()
  WHERE id IN (SELECT id FROM orders WHERE created_at IS NULL LIMIT 10000);

-- Then set the default for future rows:
ALTER TABLE orders ALTER COLUMN created_at SET DEFAULT now();
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP003: false           # disable
  MP003:
    severity: warning    # change severity
```

## Related Rules
- [MP048](./MP048.md) ban-alter-default-volatile-existing -- setting volatile default on existing column
- [MP015](./MP015.md) no-add-column-serial -- SERIAL creates implicit volatile default
- [MP011](./MP011.md) unbatched-data-backfill -- backfills should be batched
