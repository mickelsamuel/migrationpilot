# MP019: no-exclusive-lock-high-connections

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Pro

## What It Detects
ACCESS EXCLUSIVE lock on a table with many active connections causes cascading timeouts.

## Why It's Dangerous
Taking an ACCESS EXCLUSIVE lock when many connections are active means all those connections will queue waiting for the lock. This causes cascading timeouts, connection pool exhaustion, and can take down dependent services.

## Bad Example
```sql
-- With 50+ active connections to the table
ALTER TABLE users ADD COLUMN preferences jsonb;
```

## Good Example
```sql
-- Run during a low-traffic window and use a short lock_timeout:
SET lock_timeout = '3s';
ALTER TABLE users ADD COLUMN preferences jsonb;
RESET lock_timeout;

-- If lock acquisition fails, retry with exponential backoff.
-- Consider: is there a non-locking alternative? (e.g., CONCURRENTLY for indexes)
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP019: false           # disable
  MP019:
    severity: critical   # change severity
```

## Related Rules
- [MP013](./MP013.md) high-traffic-table-ddl -- DDL on high-traffic tables
- [MP004](./MP004.md) require-lock-timeout -- always set lock_timeout before DDL
- [MP014](./MP014.md) large-table-ddl -- large tables amplify lock impact
