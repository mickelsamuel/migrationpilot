# MP002: require-check-not-null-pattern

**Severity**: Critical | **Auto-fixable**: No | **Tier**: Free

## What It Detects
ALTER TABLE ... SET NOT NULL requires a full table scan to validate. Use the CHECK constraint pattern instead for large tables.

## Why It's Dangerous
SET NOT NULL requires a full table scan while holding an ACCESS EXCLUSIVE lock. The CHECK constraint + VALIDATE pattern splits this into a brief lock for adding the constraint and a longer scan under a weaker lock that allows reads and writes.

## Bad Example
```sql
ALTER TABLE users ALTER COLUMN email SET NOT NULL;
```

## Good Example
```sql
-- Step 1: Add CHECK constraint (brief ACCESS EXCLUSIVE lock, no table scan)
ALTER TABLE users ADD CONSTRAINT users_email_not_null
  CHECK (email IS NOT NULL) NOT VALID;

-- Step 2: Validate constraint (SHARE UPDATE EXCLUSIVE -- allows reads + writes)
ALTER TABLE users VALIDATE CONSTRAINT users_email_not_null;

-- Step 3: Set NOT NULL using validated constraint (PG 12+, instant)
ALTER TABLE users ALTER COLUMN email SET NOT NULL;

-- Step 4: Clean up the CHECK constraint
ALTER TABLE users DROP CONSTRAINT users_email_not_null;
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP002: false           # disable
  MP002:
    severity: warning    # change severity
```

## Related Rules
- [MP018](./MP018.md) no-force-set-not-null -- similar pattern for enforcing NOT NULL safely
- [MP030](./MP030.md) require-not-valid-check -- CHECK constraints should use NOT VALID
- [MP004](./MP004.md) require-lock-timeout -- set lock_timeout before DDL
