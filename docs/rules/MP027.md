# MP027: disallowed-unique-constraint

**Severity**: Critical | **Auto-fixable**: No | **Tier**: Free

## What It Detects
Adding a UNIQUE constraint directly scans the entire table under ACCESS EXCLUSIVE lock. Create the index concurrently first, then add the constraint USING INDEX.

## Why It's Dangerous
ALTER TABLE ADD CONSTRAINT UNIQUE builds a unique index while holding ACCESS EXCLUSIVE lock, blocking all reads and writes for the entire scan. Instead, create the unique index concurrently (non-blocking), then attach it as a constraint with USING INDEX.

## Bad Example
```sql
ALTER TABLE users ADD CONSTRAINT users_email_unique UNIQUE (email);
```

## Good Example
```sql
-- Step 1: Create the unique index concurrently (non-blocking)
CREATE UNIQUE INDEX CONCURRENTLY users_email_unique_idx ON users (email);

-- Step 2: Add the constraint using the pre-built index (instant)
ALTER TABLE users ADD CONSTRAINT users_email_unique UNIQUE USING INDEX users_email_unique_idx;
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP027: false           # disable
  MP027:
    severity: warning    # change severity
```

## Related Rules
- [MP001](./MP001.md) require-concurrent-index-creation -- indexes should use CONCURRENTLY
- [MP030](./MP030.md) require-not-valid-check -- CHECK constraints should use NOT VALID
- [MP004](./MP004.md) require-lock-timeout -- set lock_timeout before DDL
