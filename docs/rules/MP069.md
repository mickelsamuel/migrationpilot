# MP069: warn-fk-lock-both-tables

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Free

## What It Detects
ALTER TABLE ... ADD CONSTRAINT ... FOREIGN KEY which locks both the source table and the referenced table simultaneously.

## Why It's Dangerous
Adding a foreign key constraint acquires a SHARE ROW EXCLUSIVE lock on the referencing table and a SHARE lock on the referenced table. Both locks are held for the entire duration of constraint validation, which scans every row in the referencing table. On large tables this can block writes to both tables for minutes or hours. Using NOT VALID skips the initial validation scan, allowing the constraint to be added with only a brief lock. The subsequent VALIDATE CONSTRAINT runs with a weaker lock that does not block writes.

## Bad Example
```sql
ALTER TABLE orders ADD CONSTRAINT fk_user
  FOREIGN KEY (user_id) REFERENCES users (id);
-- Locks both orders AND users tables
-- Scans all rows in orders for validation
-- Blocks writes to both tables during scan
```

## Good Example
```sql
-- Step 1: Add constraint without validation (brief lock)
SET lock_timeout = '3s';
ALTER TABLE orders ADD CONSTRAINT fk_user
  FOREIGN KEY (user_id) REFERENCES users (id) NOT VALID;

-- Step 2: Validate in a separate transaction (weaker lock)
ALTER TABLE orders VALIDATE CONSTRAINT fk_user;
```

## Auto-fix
This rule is not auto-fixable. Split the foreign key addition into two steps: ADD CONSTRAINT ... NOT VALID followed by VALIDATE CONSTRAINT in a separate transaction.

## Configuration
```yaml
rules:
  MP069: false           # disable
  MP069:
    severity: critical   # upgrade from warning to critical
```

## Links
- [PostgreSQL ALTER TABLE](https://www.postgresql.org/docs/current/sql-altertable.html)
- [PostgreSQL Foreign Keys](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK)
