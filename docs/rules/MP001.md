# MP001: require-concurrent-index-creation

**Severity**: Critical | **Auto-fixable**: Yes | **Tier**: Free

## What It Detects
CREATE INDEX without CONCURRENTLY blocks all writes on the target table for the entire duration of index creation.

## Why It's Dangerous
Without CONCURRENTLY, PostgreSQL takes an ACCESS EXCLUSIVE lock on the table, blocking all reads and writes for the entire duration of index creation. On tables with millions of rows, this can mean minutes of complete downtime.

## Bad Example
```sql
CREATE INDEX idx_users_email ON users (email);
```

## Good Example
```sql
CREATE INDEX CONCURRENTLY idx_users_email ON users (email);
```

## Auto-fix
`migrationpilot analyze file.sql --fix` rewrites `CREATE INDEX` to `CREATE INDEX CONCURRENTLY` automatically.

## Configuration
```yaml
rules:
  MP001: false           # disable
  MP001:
    severity: warning    # change severity
```

## Related Rules
- [MP009](./MP009.md) require-drop-index-concurrently -- DROP INDEX should also use CONCURRENTLY
- [MP023](./MP023.md) require-if-not-exists -- indexes should use IF NOT EXISTS for idempotency
- [MP042](./MP042.md) require-index-name -- indexes should have explicit names
