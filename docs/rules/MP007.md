# MP007: no-column-type-change

**Severity**: Critical | **Auto-fixable**: No | **Tier**: Free

## What It Detects
ALTER COLUMN TYPE rewrites the entire table under ACCESS EXCLUSIVE lock. Use the expand-contract pattern instead.

## Why It's Dangerous
Changing a column type rewrites every row in the table while holding an ACCESS EXCLUSIVE lock that blocks all reads and writes. On large tables this can take hours, causing extended downtime.

## Bad Example
```sql
ALTER TABLE users ALTER COLUMN age TYPE bigint;
```

## Good Example
```sql
-- Use the expand-contract pattern:
-- Step 1: Add new column with desired type
ALTER TABLE users ADD COLUMN age_new bigint;

-- Step 2: Backfill in batches
UPDATE users SET age_new = age::bigint
  WHERE id IN (SELECT id FROM users WHERE age_new IS NULL LIMIT 10000);

-- Step 3: Create trigger to sync writes (during backfill)
-- Step 4: Swap columns (brief lock)
-- Step 5: Drop old column
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP007: false           # disable
  MP007:
    severity: warning    # change severity
```

## Related Rules
- [MP044](./MP044.md) no-data-loss-type-narrowing -- narrowing types can cause data loss
- [MP010](./MP010.md) no-rename-column -- renaming also uses expand-contract
- [MP011](./MP011.md) unbatched-data-backfill -- backfills should be batched
