# MP030: require-not-valid-check

**Severity**: Critical | **Auto-fixable**: Yes | **Tier**: Free

## What It Detects
Adding a CHECK constraint without NOT VALID scans the entire table under ACCESS EXCLUSIVE lock. Add with NOT VALID first, then VALIDATE separately.

## Why It's Dangerous
ALTER TABLE ADD CONSTRAINT CHECK validates all existing rows while holding an ACCESS EXCLUSIVE lock, blocking all reads and writes. NOT VALID skips the scan during creation (instant), then VALIDATE CONSTRAINT checks rows under a less restrictive lock that allows concurrent reads and writes.

## Bad Example
```sql
ALTER TABLE orders ADD CONSTRAINT orders_amount_positive
  CHECK (amount > 0);
```

## Good Example
```sql
-- Step 1: Add CHECK with NOT VALID (instant, no scan)
ALTER TABLE orders ADD CONSTRAINT orders_amount_positive
  CHECK (amount > 0) NOT VALID;

-- Step 2: Validate separately (SHARE UPDATE EXCLUSIVE -- allows reads + writes)
ALTER TABLE orders VALIDATE CONSTRAINT orders_amount_positive;
```

## Auto-fix
`migrationpilot analyze file.sql --fix` appends `NOT VALID` to CHECK constraint definitions automatically.

## Configuration
```yaml
rules:
  MP030: false           # disable
  MP030:
    severity: warning    # change severity
```

## Related Rules
- [MP005](./MP005.md) require-not-valid-foreign-key -- FK constraints should also use NOT VALID
- [MP002](./MP002.md) require-check-not-null-pattern -- NOT NULL via CHECK pattern
- [MP031](./MP031.md) ban-exclusion-constraint -- exclusion constraints cannot use NOT VALID
