# MP070: warn-concurrent-index-invalid

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Free

## What It Detects
CREATE INDEX CONCURRENTLY without a preceding DROP INDEX IF EXISTS for the same index name.

## Why It's Dangerous
CREATE INDEX CONCURRENTLY can fail partway through (due to deadlock, unique violation, or cancellation), leaving behind an invalid index. Invalid indexes are not used by the query planner but still consume disk space and slow down writes. Retrying the CREATE INDEX CONCURRENTLY without first dropping the invalid index will fail with "relation already exists." Adding DROP INDEX IF EXISTS before the retry ensures a clean slate and makes the migration idempotent.

## Bad Example
```sql
CREATE INDEX CONCURRENTLY idx_email ON users (email);
-- If this fails, leaves an invalid index behind
-- Retrying will fail with "relation already exists"
```

## Good Example
```sql
-- Drop any leftover invalid index from a previous failed attempt
DROP INDEX IF EXISTS idx_email;
CREATE INDEX CONCURRENTLY idx_email ON users (email);
```

## Auto-fix
This rule is not auto-fixable. Add DROP INDEX IF EXISTS before CREATE INDEX CONCURRENTLY to handle failed retries. Check for invalid indexes with: SELECT indexrelid::regclass FROM pg_index WHERE NOT indisvalid.

## Configuration
```yaml
rules:
  MP070: false           # disable
  MP070:
    severity: critical   # upgrade from warning to critical
```

## Links
- [PostgreSQL CREATE INDEX](https://www.postgresql.org/docs/current/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY)
- [PostgreSQL System Catalogs â€” pg_index](https://www.postgresql.org/docs/current/catalog-pg-index.html)
