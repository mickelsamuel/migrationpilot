# MP021: require-concurrent-reindex

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Free

## What It Detects
REINDEX without CONCURRENTLY acquires ACCESS EXCLUSIVE lock (table) or SHARE lock (index), blocking queries. Use REINDEX CONCURRENTLY on PG 12+.

## Why It's Dangerous
REINDEX without CONCURRENTLY acquires ACCESS EXCLUSIVE (table) or SHARE (index) locks, blocking all queries for the duration. REINDEX CONCURRENTLY (PG 12+) builds the new index without blocking reads or writes.

## Bad Example
```sql
REINDEX TABLE users;
```

## Good Example
```sql
REINDEX TABLE CONCURRENTLY users;
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP021: false           # disable
  MP021:
    severity: critical   # change severity
```

## Related Rules
- [MP001](./MP001.md) require-concurrent-index-creation -- CREATE INDEX should use CONCURRENTLY
- [MP009](./MP009.md) require-drop-index-concurrently -- DROP INDEX should use CONCURRENTLY
- [MP020](./MP020.md) require-statement-timeout -- set timeout for long operations
