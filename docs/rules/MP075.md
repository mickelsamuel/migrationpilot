# MP075: warn-toast-bloat-risk

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Free

## What It Detects
UPDATE statements that modify TOAST-eligible columns (TEXT, JSONB, BYTEA, and other variable-length types).

## Why It's Dangerous
PostgreSQL stores large column values in a separate TOAST table. When you UPDATE a TOAST-eligible column, PostgreSQL creates a new version of the entire TOAST entry and marks the old one as dead. Unlike regular heap tuples, dead TOAST tuples are only reclaimed by VACUUM. Bulk updates on TOAST columns can cause massive storage bloat â€” the TOAST table can grow to many times the size of the main table. This bloat persists until VACUUM runs and can degrade query performance due to increased I/O.

## Bad Example
```sql
UPDATE users SET metadata = jsonb_set(metadata, '{key}', '"value"');
-- Creates dead TOAST tuples for every row
-- TOAST table bloats until VACUUM runs
-- Can cause significant disk usage increase
```

## Good Example
```sql
-- Batch the updates to allow VACUUM between batches
UPDATE users SET metadata = jsonb_set(metadata, '{key}', '"value"')
  WHERE id BETWEEN 1 AND 10000;

-- Run VACUUM after bulk TOAST-column updates
VACUUM users;
```

## Auto-fix
This rule is not auto-fixable. Batch TOAST-column updates and schedule VACUUM after completion. Monitor TOAST table size with pg_total_relation_size().

## Configuration
```yaml
rules:
  MP075: false           # disable
  MP075:
    severity: critical   # upgrade from warning to critical
```

## Links
- [PostgreSQL TOAST](https://www.postgresql.org/docs/current/storage-toast.html)
- [PostgreSQL VACUUM](https://www.postgresql.org/docs/current/sql-vacuum.html)
