# MP067: warn-backfill-no-batching

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Free

## What It Detects
DELETE FROM ... without a WHERE clause, which removes every row in a single transaction.

## Why It's Dangerous
A DELETE without WHERE generates a massive write-ahead log (WAL), holds an ACCESS EXCLUSIVE lock for the duration, and can bloat the table with dead tuples. On large tables this can take hours, block all other queries, and fill up disk with WAL segments. TRUNCATE is significantly faster because it bypasses row-level operations entirely. For selective deletion, batched DELETE with WHERE and LIMIT prevents long-running locks and allows autovacuum to reclaim space between batches.

## Bad Example
```sql
DELETE FROM users;
-- Scans every row, generates WAL for each deletion
-- Holds lock for entire duration
-- Can fill disk with WAL on large tables
```

## Good Example
```sql
-- Option 1: TRUNCATE for full table wipe (instant, minimal WAL)
TRUNCATE users;

-- Option 2: Batched DELETE for selective removal
DELETE FROM users WHERE id IN (
  SELECT id FROM users WHERE inactive = true LIMIT 1000
);
-- Repeat in a loop until no rows remain
```

## Auto-fix
This rule is not auto-fixable. Replace unbounded DELETE with TRUNCATE for full table removal, or add WHERE and LIMIT clauses to batch the operation.

## Configuration
```yaml
rules:
  MP067: false           # disable
  MP067:
    severity: critical   # upgrade from warning to critical
```

## Links
- [PostgreSQL DELETE](https://www.postgresql.org/docs/current/sql-delete.html)
- [PostgreSQL TRUNCATE](https://www.postgresql.org/docs/current/sql-truncate.html)
