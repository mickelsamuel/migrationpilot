# MP016: require-index-on-fk

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Free

## What It Detects
Foreign key columns should have an index to avoid sequential scans on cascading updates/deletes.

## Why It's Dangerous
Without an index on foreign key columns, PostgreSQL performs sequential scans during cascading deletes and updates. On large tables, this causes long-held SHARE locks on the parent table and severely degraded write performance.

## Bad Example
```sql
ALTER TABLE orders ADD CONSTRAINT fk_orders_user
  FOREIGN KEY (user_id) REFERENCES users (id);
-- No index on orders.user_id
```

## Good Example
```sql
-- Create index on FK columns (CONCURRENTLY to avoid blocking)
CREATE INDEX CONCURRENTLY idx_orders_user_id ON orders (user_id);

ALTER TABLE orders ADD CONSTRAINT fk_orders_user
  FOREIGN KEY (user_id) REFERENCES users (id) NOT VALID;

ALTER TABLE orders VALIDATE CONSTRAINT fk_orders_user;
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP016: false           # disable
  MP016:
    severity: critical   # change severity
```

## Related Rules
- [MP005](./MP005.md) require-not-valid-foreign-key -- FK should use NOT VALID pattern
- [MP001](./MP001.md) require-concurrent-index-creation -- indexes should use CONCURRENTLY
- [MP042](./MP042.md) require-index-name -- indexes should have explicit names
