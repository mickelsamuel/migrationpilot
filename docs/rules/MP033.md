# MP033: require-concurrent-refresh-matview

**Severity**: Warning | **Auto-fixable**: Yes | **Tier**: Free

## What It Detects
REFRESH MATERIALIZED VIEW without CONCURRENTLY takes ACCESS EXCLUSIVE lock, blocking all reads. Use CONCURRENTLY to allow reads during refresh.

## Why It's Dangerous
REFRESH MATERIALIZED VIEW without CONCURRENTLY takes an ACCESS EXCLUSIVE lock for the entire refresh duration, blocking all queries against the view. REFRESH CONCURRENTLY allows reads to continue using the old data while the new data is being computed. Requires a UNIQUE index on the materialized view.

## Bad Example
```sql
REFRESH MATERIALIZED VIEW analytics_summary;
```

## Good Example
```sql
-- Use CONCURRENTLY to allow reads during refresh (requires a UNIQUE index):
REFRESH MATERIALIZED VIEW CONCURRENTLY analytics_summary;
```

## Auto-fix
`migrationpilot analyze file.sql --fix` rewrites `REFRESH MATERIALIZED VIEW` to `REFRESH MATERIALIZED VIEW CONCURRENTLY` automatically.

## Configuration
```yaml
rules:
  MP033: false           # disable
  MP033:
    severity: critical   # change severity
```

## Related Rules
- [MP001](./MP001.md) require-concurrent-index-creation -- indexes should use CONCURRENTLY
- [MP009](./MP009.md) require-drop-index-concurrently -- DROP INDEX should use CONCURRENTLY
- [MP020](./MP020.md) require-statement-timeout -- long-running operations need timeouts
