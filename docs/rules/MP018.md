# MP018: no-force-set-not-null

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Free

## What It Detects
SET NOT NULL without a pre-existing CHECK constraint scans the entire table under ACCESS EXCLUSIVE lock.

## Why It's Dangerous
SET NOT NULL scans every row to verify no NULLs while holding an ACCESS EXCLUSIVE lock. On PostgreSQL 12+, adding a CHECK (col IS NOT NULL) NOT VALID constraint first, validating it, then SET NOT NULL makes the final step instant.

## Bad Example
```sql
ALTER TABLE users ALTER COLUMN email SET NOT NULL;
```

## Good Example
```sql
-- PG 12+ safe approach:
-- Step 1: Add CHECK constraint NOT VALID (instant, no scan)
ALTER TABLE users ADD CONSTRAINT users_email_not_null
  CHECK (email IS NOT NULL) NOT VALID;

-- Step 2: Validate separately (SHARE UPDATE EXCLUSIVE -- allows reads + writes)
ALTER TABLE users VALIDATE CONSTRAINT users_email_not_null;

-- Step 3: SET NOT NULL is now instant (PG sees the validated CHECK)
ALTER TABLE users ALTER COLUMN email SET NOT NULL;
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP018: false           # disable
  MP018:
    severity: critical   # change severity
```

## Related Rules
- [MP002](./MP002.md) require-check-not-null-pattern -- same CHECK constraint pattern
- [MP030](./MP030.md) require-not-valid-check -- CHECK constraints should use NOT VALID
- [MP029](./MP029.md) ban-drop-not-null -- dropping NOT NULL can break application code
