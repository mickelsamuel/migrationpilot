# MP048: ban-alter-default-volatile-existing

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Free

## What It Detects
Setting a volatile default (now(), random(), gen_random_uuid()) on an existing column has no effect on existing rows, which may cause confusion.

## Why It's Dangerous
ALTER TABLE ALTER COLUMN SET DEFAULT only affects future INSERTs -- existing rows are NOT updated. Setting a volatile function like now() or gen_random_uuid() as default may give the false impression that existing NULLs will be filled. You likely need a backfill UPDATE as well.

## Bad Example
```sql
ALTER TABLE users ALTER COLUMN created_at SET DEFAULT now();
-- Existing rows with NULL created_at remain NULL!
```

## Good Example
```sql
-- SET DEFAULT only affects new rows. To backfill existing rows:
-- 1. Set the default for future inserts:
ALTER TABLE users ALTER COLUMN created_at SET DEFAULT now();

-- 2. Backfill existing rows (in batches for large tables):
UPDATE users SET created_at = now() WHERE created_at IS NULL;
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP048: false           # disable
  MP048:
    severity: critical   # change severity
```

## Related Rules
- [MP003](./MP003.md) volatile-default-table-rewrite -- ADD COLUMN with volatile default
- [MP011](./MP011.md) unbatched-data-backfill -- backfills should be batched
- [MP015](./MP015.md) no-add-column-serial -- SERIAL creates implicit volatile default
