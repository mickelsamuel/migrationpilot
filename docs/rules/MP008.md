# MP008: no-multi-ddl-transaction

**Severity**: Critical | **Auto-fixable**: No | **Tier**: Free

## What It Detects
Multiple DDL statements in a single transaction compound lock duration. Each DDL should run in its own transaction.

## Why It's Dangerous
When multiple DDL statements run in one transaction, all locks are held until COMMIT. This multiplies the downtime window -- the total lock time is the sum of all DDL operations, not just the longest one.

## Bad Example
```sql
BEGIN;
ALTER TABLE users ADD COLUMN age integer;
ALTER TABLE users ADD COLUMN bio text;
CREATE INDEX CONCURRENTLY idx_users_age ON users (age);
COMMIT;
```

## Good Example
```sql
-- Run each DDL in its own transaction:
ALTER TABLE users ADD COLUMN age integer;

ALTER TABLE users ADD COLUMN bio text;

-- Note: CONCURRENTLY cannot run inside a transaction
CREATE INDEX CONCURRENTLY idx_users_age ON users (age);
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP008: false           # disable
  MP008:
    severity: warning    # change severity
```

## Related Rules
- [MP025](./MP025.md) ban-concurrent-in-transaction -- CONCURRENTLY cannot run in transactions
- [MP004](./MP004.md) require-lock-timeout -- set lock_timeout before each DDL
- [MP001](./MP001.md) require-concurrent-index-creation -- indexes should use CONCURRENTLY
