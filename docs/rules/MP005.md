# MP005: require-not-valid-foreign-key

**Severity**: Critical | **Auto-fixable**: No | **Tier**: Free

## What It Detects
Adding a FK constraint without NOT VALID scans the entire table under ACCESS EXCLUSIVE lock.

## Why It's Dangerous
Adding a foreign key validates all existing rows while holding an ACCESS EXCLUSIVE lock. NOT VALID skips validation during creation, then VALIDATE CONSTRAINT checks rows with a SHARE UPDATE EXCLUSIVE lock that allows reads and writes.

## Bad Example
```sql
ALTER TABLE orders ADD CONSTRAINT fk_orders_user
  FOREIGN KEY (user_id) REFERENCES users (id);
```

## Good Example
```sql
-- Step 1: Add FK with NOT VALID (brief lock, no scan)
ALTER TABLE orders ADD CONSTRAINT fk_orders_user
  FOREIGN KEY (user_id) REFERENCES users (id) NOT VALID;

-- Step 2: Validate separately (SHARE UPDATE EXCLUSIVE -- allows reads + writes)
ALTER TABLE orders VALIDATE CONSTRAINT fk_orders_user;
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP005: false           # disable
  MP005:
    severity: warning    # change severity
```

## Related Rules
- [MP016](./MP016.md) require-index-on-fk -- FK columns should have an index
- [MP030](./MP030.md) require-not-valid-check -- CHECK constraints should also use NOT VALID
- [MP004](./MP004.md) require-lock-timeout -- set lock_timeout before DDL
