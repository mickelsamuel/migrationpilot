# MP031: ban-exclusion-constraint

**Severity**: Critical | **Auto-fixable**: No | **Tier**: Free

## What It Detects
Adding an EXCLUSION constraint builds a GiST index and scans the entire table under ACCESS EXCLUSIVE lock. This cannot use NOT VALID.

## Why It's Dangerous
EXCLUSION constraints require a GiST index, which is built inline while holding ACCESS EXCLUSIVE lock. Unlike CHECK or FK constraints, exclusion constraints have no NOT VALID option -- the full table scan and index build happen atomically, blocking all reads and writes for the entire duration.

## Bad Example
```sql
ALTER TABLE reservations ADD CONSTRAINT no_overlap
  EXCLUDE USING gist (room_id WITH =, tsrange(start_time, end_time) WITH &&);
```

## Good Example
```sql
-- Exclusion constraints cannot be added without locking.
-- Consider these alternatives:
-- 1. Add during a maintenance window
-- 2. Create the table with the exclusion constraint from the start
-- 3. Use application-level uniqueness checking with advisory locks
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP031: false           # disable
  MP031:
    severity: warning    # change severity
```

## Related Rules
- [MP027](./MP027.md) disallowed-unique-constraint -- UNIQUE constraints should use USING INDEX
- [MP030](./MP030.md) require-not-valid-check -- CHECK constraints should use NOT VALID
- [MP004](./MP004.md) require-lock-timeout -- set lock_timeout before DDL
