# MP009: require-drop-index-concurrently

**Severity**: Warning | **Auto-fixable**: Yes | **Tier**: Free

## What It Detects
DROP INDEX without CONCURRENTLY acquires ACCESS EXCLUSIVE lock, blocking all reads and writes.

## Why It's Dangerous
DROP INDEX without CONCURRENTLY takes an ACCESS EXCLUSIVE lock on the table, blocking all reads and writes until the index is fully dropped. DROP INDEX CONCURRENTLY avoids this by using a multi-phase approach.

## Bad Example
```sql
DROP INDEX idx_users_email;
```

## Good Example
```sql
DROP INDEX CONCURRENTLY idx_users_email;
```

## Auto-fix
`migrationpilot analyze file.sql --fix` rewrites `DROP INDEX` to `DROP INDEX CONCURRENTLY` automatically.

## Configuration
```yaml
rules:
  MP009: false           # disable
  MP009:
    severity: critical   # change severity
```

## Related Rules
- [MP001](./MP001.md) require-concurrent-index-creation -- CREATE INDEX should also use CONCURRENTLY
- [MP025](./MP025.md) ban-concurrent-in-transaction -- CONCURRENTLY cannot run in transactions
- [MP004](./MP004.md) require-lock-timeout -- set lock_timeout before DDL
