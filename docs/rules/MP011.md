# MP011: unbatched-data-backfill

**Severity**: Warning | **Auto-fixable**: No | **Tier**: Free

## What It Detects
UPDATE without a WHERE clause or LIMIT pattern rewrites the entire table in a single transaction, generating massive WAL and holding locks.

## Why It's Dangerous
A full-table UPDATE generates massive WAL, bloats the table, and holds a ROW EXCLUSIVE lock for the entire duration. On tables with millions of rows, this can take hours and cause replication lag, disk pressure, and degraded performance.

## Bad Example
```sql
UPDATE users SET status = 'active';
```

## Good Example
```sql
-- Backfill in batches to reduce lock duration and WAL volume:
DO $$
DECLARE
  batch_size INT := 10000;
  rows_updated INT;
BEGIN
  LOOP
    UPDATE users
    SET status = 'active'
    WHERE status IS NULL
    AND ctid IN (
      SELECT ctid FROM users
      WHERE status IS NULL
      LIMIT batch_size
      FOR UPDATE SKIP LOCKED
    );
    GET DIAGNOSTICS rows_updated = ROW_COUNT;
    EXIT WHEN rows_updated = 0;
    COMMIT;
    PERFORM pg_sleep(0.1);
  END LOOP;
END $$;
```

## Auto-fix
This rule is not auto-fixable. Manual intervention required.

## Configuration
```yaml
rules:
  MP011: false           # disable
  MP011:
    severity: critical   # change severity
```

## Related Rules
- [MP003](./MP003.md) volatile-default-table-rewrite -- volatile defaults may need backfills
- [MP007](./MP007.md) no-column-type-change -- type changes require batched backfills
- [MP010](./MP010.md) no-rename-column -- column renames require data migration
